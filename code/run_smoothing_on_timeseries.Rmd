# Run some basic smoothing on a timeseries

## Create functions

```{r,create_funcs}
#' Fit a spline to a collection of timeseries, with a possible roughness penalty
#'
#' @param data_to_smooth A data frame. Rows correspond to different time points
#' and columns correspond to different variables.
#' @param timepoints A vector (numeric). Corresponds to the measurement 
#' timepoints of each variable.
#' @param nbasis_in Integer. The number of basis functions to use.
#' @param lambda_in Float. Defaults to 0. The value of the smoothing parameter,
#' lambda.
#' @param basis_type String. Defaults to "fourier". Can be either "fourier" or
#' "bspline" to select different families of basis functions.
#' @param norder_in Integer. Defaults to 4. Only relevant if basis_type = 
#' TRUE. Controls the order of the bspline functions.
#'
#' @return An fdSmooth object.
fits_from_params <- function(data_to_smooth,
                             timepoints,
                             nbasis_in,
                             lambda_in = 0,
                             basis_type = "fourier",
                             norder_in = 4) {
  range_of_timeseries <- c(min(timepoints), max(timepoints))
  
  penalty_basis <- switch(
    basis_type,
    fourier = fda::create.fourier.basis(
      rangeval = range_of_timeseries,
      nbasis = nbasis_in,
      
    ),
    bspline = fda::create.bspline.basis(
      rangeval = range_of_timeseries,
      nbasis = nbasis_in,
      norder = norder_in
    )
  )
  
  if (is.null(penalty_basis)) {
    stop('basis_type not recognised - must be "fourier" or "bspline"')
  }
  
  
  # Define a linear differential operator
  second_deriv_operator = fda::int2Lfd(2)
  
  fd_params = fda::fdPar(penalty_basis, second_deriv_operator, lambda_in)
  fd_outputs = fda::smooth.basis(
    timepoints,
    data_to_smooth, 
    fd_params
  )
  
  return(fd_outputs)
  
}
```

```{r, timeseries_smoothing}

# generate some toy data

set.seed(123)  # for reproducibility

arg_vals_days <- 1:(2*365)
num_reps <- 5
mean_of_noise <- 0.2
eg_trends <- runif(num_reps, min = -5, max = 5)  # allows for different trend lines

eg_df <- data.frame(matrix(nrow = length(arg_vals_days),
                           ncol = num_reps))
colnames(eg_df) <- 1:num_reps

for (j in 1:num_reps) {
  eg_fluc_data <- sapply(
    arg_vals_days,
    function(i) {
      40 + eg_trends[j]*(i/365)**2 + 5*cos(i*2*pi/365) + 0.3 * sin(i*pi/3)
    }
  ) + rnorm(length(arg_vals_days), mean = mean_of_noise)
  eg_df[, j] <- eg_fluc_data
}


matplot(eg_df, type = 'l', col = 1:num_reps, lty = 1)
```

You can fit this data multiple ways:
- a standard fourier basis, with few basis functions
- a standard fourier basis, with many basis functions, and smoothing
- same as above but with bspline basis

```{r, smooth}
basic_output_fits <- fits_from_params(
  as.matrix(eg_df),
  arg_vals_days,
  10,
  lambda_in = 5,
  basis_type = "bspline",
  norder = 4
)

matplot(eg_df, type = 'l', col = 1:num_reps, lty = 1)
lines(basic_output_fits, 
      col = 1:num_reps,
      main = "Unregularised fourier fit",
      lty = 1)
```